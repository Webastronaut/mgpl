/*
 * generated by Xtext 2.9.0
 */
package mgpl.validation

import mgpl.mGPL.AnimBlock
import mgpl.mGPL.ArrayDecl
import mgpl.mGPL.AssStmt
import mgpl.mGPL.AttrAss
import mgpl.mGPL.Complement
import mgpl.mGPL.ElementSelect
import mgpl.mGPL.Expr
import mgpl.mGPL.MGPLPackage
import mgpl.mGPL.MemberSelect
import mgpl.mGPL.Negation
import mgpl.mGPL.NumberLiteral
import mgpl.mGPL.ObjDecl
import mgpl.mGPL.ParamDecl
import mgpl.mGPL.Prog
import mgpl.mGPL.Touches
import mgpl.mGPL.Var
import mgpl.mGPL.VarDecl
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check

import static extension mgpl.Common.*
import org.eclipse.emf.common.util.EList

// Super Video: https://www.youtube.com/watch?v=8EQ1dW06G48
/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MGPLValidator extends AbstractMGPLValidator {

	/* 
	 * ##### Vordefinierte Hilfsfunktionen & globale Variablen.
	 * ##### Verwenden Sie diese wenn möglich. 
	 * ##### Verwenden Sie ggf. auch die statischen Funktionen der Datei Common.xtend
	 * ##### TODOs für @Check Implementierung hier weiter unten!
	 */
	// Verschiedene Instanzabfragen 
	// id.eIsProxy ist wahr wenn der Querverweis nicht hergestellt werden kann
	def isUndeclared(Var it) { id == null || id.eIsProxy } // it.id 

	def isArray(Var it) { id.eContainer instanceof ArrayDecl } // mit it.id gelangen wir VarDecl oder ArrayDecl

	def isGame(Var it) { id instanceof Prog }

	def isVariable(Var it) { id instanceof VarDecl }

	def isObject(Var it) { id instanceof ObjDecl }

	def isAnimation(Var it) { id instanceof AnimBlock }

	def isParameter(Var it) { id instanceof ParamDecl }

	def hasMembers(Var it) { // wird aufgerufen bei einem Var-Ausdruck der Form v.h, ohne Array-Index
		isGame || isObject && !isArray || isParameter // möglich isGame(it) oder it.isGame
	}

	// zeigt, ob die Variable als Array benutzt wird
	def usedAsArray(Var it) {
		eContainer instanceof ElementSelect && eContainingFeature == MGPLPackage.Literals.VAR__VARIABLE
	/* aliens[1+3], bullets[i] */
	}

	// zeigt, ob Var-Instanz als Objekt verwendet wird
	def usedAsObject(Var it) {
		eContainer instanceof MemberSelect
	/*aliens[i].visible = 0; cur_bullet.visible = 0; */
	}

	// wird auf die Operanden von Touches(einmal für left und einmal für right) aufgerufen
	// zeigt, ob der Operand kein graphisches Objekt ist. (also kein circle, triangle, rectangle)
	def isNoGraphicalObject(Var it) {
		it instanceof MemberSelect || if (it instanceof ElementSelect)
			!variable.isUndeclared && !variable.isObject && variable.isArray
		else
			!isUndeclared && (!isObject || isArray) && !isParameter
	}

	// Die Methode wird für jeden atomaren Operanden aufgerufen, also zweimal bei binären Operatoren.
	// Wenn ein Attribut animation_Block ist, ist es kein Integer, sonst sind alle anderen Attribute Integers
	def isNoInt(Var it) {
		if (it instanceof MemberSelect)
			memberName.equals('animation_block')
		else if (it instanceof ElementSelect)
			!variable.isUndeclared && !variable.isVariable && variable.isArray
		else
			!isUndeclared && (!isVariable || isArray)
	}

	val gameAttributes = #['height', 'width', 'speed', 'x', 'y']
	val circleAttributes = #['animation_block', 'radius', 'visible', 'x', 'y']
	val rectTriangleAttributes = #['animation_block', 'height', 'visible', 'width', 'x', 'y']

	// liefert die für das übergebene Objekt erlaubten Attribute
	def allowedAttributes(EObject it) {
		if (it instanceof ObjDecl)
			if(type.equals('circle')) circleAttributes else rectTriangleAttributes
		else if (it instanceof ParamDecl)
			if(type.equals('circle')) circleAttributes else rectTriangleAttributes
		else if(it instanceof Prog) gameAttributes
	}

	// dient zur Konstruktion von Fehlermeldungen mit großgeschriebenen Objektarten
	def objectType(EObject it) {
		if (it instanceof ObjDecl)
			type.capitalize
		else if(it instanceof ParamDecl) type.capitalize else if(it instanceof Prog) 'Game'
	}

	def hasDuplicateAttrs(String attrName, EList<AttrAss> attrs) {
		val attrNames = newArrayList()
		val a = shortAttributeName(attrName)

		for (attr : attrs) {
			val shortname = shortAttributeName(attr.name)

			if (!(attrNames.contains(shortname) && a.equals(shortname))) {
				attrNames.add(shortname)
			} else {
				return attrNames.contains(shortname) && a.equals(shortname)
			}
		}

		return attrNames.contains("$")
	}

	/* 
	 * ##### Vordefinierte @Check Funktion als Orientierungshilfe.
	 */
	// prüfen, dass Operanden von touches grafische Objekte sind und von allen anderen Operatoren Integers
	@Check
	def checkExpressionOperands(Expr it) {
		if(it instanceof NumberLiteral || it instanceof Var) return;
		if (it instanceof Touches) {
			if (left.isNoGraphicalObject)
				error('This Operand must evaluate to a Circle, Rectangle, or Triangle',
					MGPLPackage.Literals.TOUCHES__LEFT)
			if (right.isNoGraphicalObject)
				error('This Operand must evaluate to a Circle, Rectangle, or Triangle',
					MGPLPackage.Literals.TOUCHES__RIGHT)
		} else if (it instanceof Negation || it instanceof Complement) {
			val feature = eClass.getEStructuralFeature(MGPLPackage.Literals.NEGATION__EXPR.name)
			val expr = eGet(feature)
			if (expr instanceof Var)
				if (expr.isNoInt)
					error('This Operand must evaluate to an int', feature)
		} else {
			val leftFeature = eClass.getEStructuralFeature(MGPLPackage.Literals.EQUALS__LEFT.name)
			val rightFeature = eClass.getEStructuralFeature(MGPLPackage.Literals.EQUALS__RIGHT.name)
			val left = eGet(leftFeature)
			val right = eGet(rightFeature)
			if (left instanceof Var)
				if (left.isNoInt)
					error('This Operand must evaluate to an int', leftFeature)
			if (right instanceof Var)
				if (right.isNoInt)
					error('This Operand must evaluate to an int', rightFeature)
		}
	}

	/* 
	 * ##### Ihre Implementierung der @Check Funktion für Aufgabe 2.
	 */
	@Check
	def checkVar(Var it) {
		/*TODO Philip*/
		// IMPORTANT NOTE: unknown variables are already handled
//		System.out.println(String.format("Node on line %s",NodeModelUtils.getNode(it).getStartLine()));
		// prüfen, dass sämtliche Vorkommen von Variablen- oder Objektnamen deklaiert sind und wie es verwendet wird (Aufg. 2. Bindungen)
		if (!isArray && !isObject) { // int/parameter/game
			if (isParameter || isGame) { // param may be used as object but not otherwise
				if (usedAsArray) {
					error("Invalid array access on " + it.id.name,
						eClass.getEStructuralFeature(MGPLPackage.Literals.VAR__VARIABLE.name))
				}
			} else { // all other objects are not allowed to be used as arrays/objects
				if (usedAsArray || usedAsObject) {
					error("Invalid array/member access on " + it.id.name,
						eClass.getEStructuralFeature(MGPLPackage.Literals.VAR__VARIABLE.name))
				}
			}
		} else if (isArray && !isObject) { // int arrays
			if (usedAsObject) {
				error("Invalid member access on array " + it.id.name,
					eClass.getEStructuralFeature(MGPLPackage.Literals.VAR__VARIABLE.name))
			}
		} else if (!isArray && isObject) { // object
			if (usedAsArray) {
				error("Invalid array access on object " + it.id.name,
					eClass.getEStructuralFeature(MGPLPackage.Literals.VAR__VARIABLE.name))
			}
		} else { // object array
			if (!usedAsObject) {
				val parent = eContainer.eContainer
				if (parent instanceof AssStmt) {
					if (!(parent instanceof Expr)) { // lefthand side assignment (bullets[i] = ...)
						error("Invalid access on array object " + it.id.name,
							eClass.getEStructuralFeature(MGPLPackage.Literals.VAR__VARIABLE.name))
					}
				}
			} else if (!usedAsArray) {
				error("Invalid access on array object " + it.id.name,
					eClass.getEStructuralFeature(MGPLPackage.Literals.VAR__VARIABLE.name))
			}
		}
	}

	@Check
	def checkAttributeAssignment(AttrAss it) {
		/*TODO Philip*/
		// IMPORTANT NOTE: duplicates are checked out of the box
		// System.out.println(String.format("Node on line %s",NodeModelUtils.getNode(it).getStartLine()));
		if (it.eContainer instanceof Prog || it.eContainer instanceof ObjDecl) {
			val parent = it.eContainer
			val allowed = parent.allowedAttributes

			// prüfen, dass dieses Attribut für dieses Objekt erlaubt ist (Aufg. 2. Attribute)
			if (it.name.length() == 1 && (!it.name.equals("x") && !it.name.equals("y"))) { // shorthands h(eight), r(adius), w(idth) allowed
				if (!isShortAttributeName(it.name)) {
					error("Unknown shorthand " + it.name,
						eClass.getEStructuralFeature(MGPLPackage.Literals.ATTR_ASS__NAME.name))
				}
			} else if (!allowed.contains(it.name)) { // unknown attributes not allowed
				error("Unknown attribute " + it.name,
					eClass.getEStructuralFeature(MGPLPackage.Literals.ATTR_ASS__NAME.name))
			}

			// ugly!
			if (parent instanceof Prog) {
				// prüfen, dass dieses Attribut, das einen langen und einen kurzen Namen haben kann, nur einmal in diesem Objekt belegt wird (Aufg. 2. Attribute)
				if (hasDuplicateAttrs(it.name, parent.attr)) {
					error("Attribute " + longAttributeName(it.name) + " already set",
						eClass.getEStructuralFeature(MGPLPackage.Literals.ATTR_ASS__NAME.name))
				}

				// prüfen, dass das Game-Attribut speed mit einem Wert zwischen 0 und 100 belegt wird (Aufg. 2. Attribute)
				if (it.value instanceof NumberLiteral) {
					val num = (it.value as NumberLiteral).value

					if (it.name.equals("speed") && (num < 0 || num > 100)) {
						error("Value out of range. Speed range is [0..100]",
							eClass.getEStructuralFeature(MGPLPackage.Literals.ATTR_ASS__VALUE.name))
					}
				} else {
					// prüfen, dass Game-Attribute nur mit konstanten Zahlen belegt werden (Aufg. 2. Attribute)
					// decimal values?
					error("Object game allows only number literals as attribute values",
						eClass.getEStructuralFeature(MGPLPackage.Literals.ATTR_ASS__VALUE.name))
				}
			} else if (parent instanceof ObjDecl) {
				// prüfen, dass dieses Attribut, das einen langen und einen kurzen Namen haben kann, nur einmal in diesem Objekt belegt wird (Aufg. 2. Attribute)
				if (hasDuplicateAttrs(it.name, parent.attr)) {
					error("Attribute " + longAttributeName(it.name) + " already set",
						eClass.getEStructuralFeature(MGPLPackage.Literals.ATTR_ASS__NAME.name))
				}

				if (it.name.equals("animation_block")) {
					if (it.value instanceof Var) {
						val value = it.value as Var

						// prüfen, dass das Grafikobjekt-Attribut animation_block mit dem Namen eines Animation-Handlers belegt wird (Aufg. 2. Bindungen)
						if (value.id instanceof AnimBlock) {
							val animblock = value.id as AnimBlock

							// prüfen, dass der Animation-Handler einen passenden Typ hat (Aufg. 2. Bindungen)
							if (!parent.type.equals(animblock.param.type)) {
								error("Type of object and animation block parameter must match",
									eClass.getEStructuralFeature(MGPLPackage.Literals.ATTR_ASS__VALUE.name))
							}
						} else {
							error(value.id.name + " is not an animation block",
								eClass.getEStructuralFeature(MGPLPackage.Literals.ATTR_ASS__VALUE.name))
						}

					} else {
						error("Invalid value for animation_block",
							eClass.getEStructuralFeature(MGPLPackage.Literals.ATTR_ASS__VALUE.name))
					}
				}
			}
		}
	}

	@Check
	def checkMemberName(MemberSelect it) {
		/*TODO*/
		val obj = eClass.getEStructuralFeature(MGPLPackage.Literals.MEMBER_SELECT.getName());
		val attr = allowedAttributes(variable.id);
		val longMemberName = longAttributeName(memberName)

		if (variable.isObject) {
			if (attr.indexOf(longMemberName) < 0) {
				error(longMemberName + ' is not a member of this object', obj)

			}
		} else {
			val arrattr = allowedAttributes(it.variable.variable.id);

			if (arrattr.indexOf(longMemberName) < 0) {
				error('Invalid member access on object array', obj)

			}
		}
	// prüfen, ob ein verwendetes Attribut für das jeweilige Objekt erlaubt ist (Aufg. 2. Bindungen)
	}

	@Check
	def checkAnimation_blockAssignment(AssStmt it) {
		/*TODO*/
		val expFeature = eClass.getEStructuralFeature(MGPLPackage.Literals.ASS_STMT__EXPRESSION.getName())
		val paramFeature = eClass.getEStructuralFeature(MGPLPackage.Literals.ANIM_BLOCK__PARAM.getName())
		
		if (!(variable.isNoInt)) {
			return;
		}
		
		if (variable instanceof Var && expression instanceof Var) {
			val c = variable.variable.variable.id;
			val cType = (c as ObjDecl).getType();
			
			if (((expression as Var).isAnimation)) {
				val param = ((expression as Var).id.eContents.filter[s|s instanceof ParamDecl].get(0) as ParamDecl).
					type.toString
				
				// --> Wenn ein Attribut animation_Block ist, ist es kein Integer, sonst sind alle anderen Attribute Integers
				if (!(param.equals(cType))) {
					error('Parameter of animation block and object do not have matching types', paramFeature)
				}
			} else {
				if((it.expression as Var).id.name != null) {
					error((it.expression as Var).id.name + ' is not an animation block', expFeature)
				} else {
					error("Invalid animation block name", expFeature)
				}
			}
		} else {
			error('Invalid animation block name', expFeature)
		}
	}
}
